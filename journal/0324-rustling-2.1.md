## 2.1 变量绑定与解构

*   rust里，需要声明可变变量，因为rust既要灵活性又要安全性（也提升了运行性能）

    **一切选择皆是权衡**

*   \*\*变量绑定 \*\*

    `let a = "hello world”；` 

    为什么不用赋值而用绑定？：有关**所有权**，后面讲

*   **变量可变性**
    ```rust
    fn main() {
        let mut x = 5;//如果不用mut就会报错，因为那样创建的x是不可变的变量
        println!("The value of x is: {}", x);
        x = 6;
        println!("The value of x is: {}", x);
    }
    ```

&#x9;	`let mut x = 5;`

*   **告诉 Rust 不要警告未使用的变量**

    如果创建了一个变量却不在任何地方使用它，Rust 通常会给一个警告，因为这可能会是个 BUG

    在变量前加下划线可以不让rust警告

    `let _x = 5;`

*   **变量的解构**

    解构啥意思？

    > "解构"是指从复合数据类型（如元组、结构体、枚举等）中提取出部分或全部数据元素，并将它们绑定到变量上的过程。这与传统的变量赋值不同，后者只是将整个数据类型的值赋给一个变量。解构允许开发者更灵活地处理复杂的数据结构，可以按需提取出感兴趣的部分。

    e.g.：

    `let person = ("张三", 30);`

    可以改成：

    `let (name, age) = person;`

    这样，`name` 变量就被绑定到了 `"张三"`，而 `age` 变量被绑定到了 `30`

    > `let` 表达式不仅仅用于变量的绑定，还能进行复杂变量的解构：从一个相对复杂的变量中，匹配出该变量的一部分内容

    *   解构式赋值

        可以在赋值语句的左式中使用元组、切片和结构体模式

```rust
struct Struct {
    e: i32
}

fn main() {
    let (a, b, c, d, e);

    (a, b) = (1, 2);
    // _ 代表匹配一个值，但是我们不关心具体的值是什么，因此没有使用一个变量名而是使用了 _
    [c, .., d, _] = [1, 2, 3, 4, 5];
    Struct { e, .. } = Struct { e: 5 };

    assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]);
}
```

> 这种使用方式跟之前的 `let` 保持了一致性，但是 `let` 会重新绑定，而这里仅仅是对之前绑定的变量进行再赋值。

*   *使用* `+=` *的赋值语句还不支持解构式赋值*

*   **变量和常量之间的差异**

    *++// 刚学了c++的const，这下知道了，回来看看++*

    **常量不允许使用** `mut`

    **==常量不仅仅默认不可变，而且自始至终不可变==**

*   `const MAX_POINTS: u32 = 100_000;`

*   **变量遮蔽(shadowing)**

> Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的

```rust
fn main() {
    let x = 5;
    // 在main函数的作用域内对之前的x进行遮蔽
    let x = x + 1;

    {
        // 在当前的花括号作用域内，对之前的x进行遮蔽
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}
```

&#x9;	输出：

*   `The value of x in the inner scope is: 12`\
    `The value of x is: 6`

这样的好处是之前不用的变量名可以重复再用

## 课后习题

assert\_eq!是个啥：

==在Rust编程语言中，====`assert_eq!`====是一个宏，用于断言两个表达式是否相等。如果两个表达式不相等，====`assert_eq!`====宏会导致程序 panic，即立即终止执行==

*   第四题

```rust
// 修复错误
fn main() {
    println!("{}, world", x); 
}

fn define_x() {
    let x = "hello";
}
//------------------改为-----------------------
fn main() {
	let x = "hello";
    println!("{}, world", x); 
}
```

在Rust中，变量是有作用域的，这意味着它们仅在其定义的块（如函数）中有效。因此，`main`函数无法访问`define_x`函数中定义的`x`。

*   第六题

```rust
fn main() {
    let mut x: i32 = 1;
    x = 7;
    // 遮蔽且再次绑定
    let mut x = x; //在这里加mut
    x += 3;


    let y = 4;
    // 遮蔽
    let y = "I can also be bound to text!"; 
```

对于`x`，它最初被绑定到一个`i32`类型的值`1`，然后被重新绑定到值`7`，接着再次被遮蔽并绑定到自身，但是这次作为一个不可变的绑定。因此，尝试对`x`进行`+=`操作会导致编译错误，因为它现在是不可变的。
