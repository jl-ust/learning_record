## 2.2.4 函数

```rust
fn add(i: i32, j: i32) -> i32 {
i + j
}
```

![](https://pic2.zhimg.com/80/v2-54b3a6d435d2482243edc4be9ab98153_1440w.png)

*   **函数要点**

    函数名和变量名使用蛇形命名法(snake case)，例如 `fn add_two() -> {}`
*   **函数参数**

    Rust 是强类型语言，因此==需要为每一个函数参数都标识出它的具体类型==
*   **函数返回**

    函数是表达式

    > 函数的返回值就是函数体最后一条表达式的返回值，当然我们也可以使用 `return` 提前返回。
*   **Rust 中的特殊返回类型**
    1.无返回值`()`
    函数没有返回值，那么返回一个 ()
    通过 ; 结尾的语句返回一个 ()
    2.永不返回的发散函数！
    当用 ! 作函数返回类型的时候，表示该函数永不返回( diverge function )，特别的，这种语法往往用做会导致程序崩溃的函数：

```rust
fn dead_end() -> ! {
  panic!("你已经到了穷途末路，崩溃吧！");
}
```

```rust
fn forever() -> ! {
  loop {
    //...
  };
}
```

## 2.3 所有权和借用

> Rust 之所以能成为万众瞩目的语言，就是因为其内存安全性。在以往，内存安全几乎都是通过 GC 的方式实现，但是 GC 会引来性能、内存占用以及 Stop the world 等问题，在高性能场景和系统编程上是不可接受的，因此 Rust 采用了与 ( 不 ) 众 ( 咋 ) 不 ( 好 ) 同 ( 学 )的方式：**==所有权系统==**。

### 2.3.1 所有权

*   在计算机语言不断演变过程中，出现了三种管理计算机内存的流派：

    **垃圾回收机制(GC)**，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go

    **手动管理内存的分配和释放**, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++

    **通过所有权来管理内存**，编译器在编译时会根据一系列规则进行检查

*   **一段不安全的代码**

```c
int* foo() {
    int a;          // 变量a的作用域开始
    a = 100;
    char *c = "xyz";   // 变量c的作用域开始
    return &a;
}                   // 变量a和c的作用域结束

```

> 变量 `a` 和 `c` 都是局部变量，函数结束后将局部变量 `a` 的地址返回，但局部变量 `a` 存在栈中，在离开作用域后，`a` 所申请的栈上内存都会被系统回收，从而造成了 `悬空指针(Dangling Pointer)` 的问题。这是一个非常典型的内存安全问题，虽然编译可以通过，但是运行的时候会出现错误, 很多编程语言都存在。

> 再来看变量 `c`，`c` 的值是常量字符串，存储于常量区，可能这个函数我们只调用了一次，也可能我们不再会使用这个字符串，但 `"xyz"` 只有当整个程序结束后系统才能回收这片内存。

*   **栈(Stack)与堆(Heap)**

对于 Rust 这样的系统编程语言，值是位于栈上还是堆上非常重要, 因为这会影响程序的行为和性能。

**==栈和堆的核心目标就是为程序在运行时提供可供使用的内存空间。==**

*   栈

    栈按照顺序存储值并以相反顺序取出值，这也被称作\*\*==后进先出==\*\*。*想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，再从顶部拿走。不能从中间也不能从底部增加或拿走盘子！*

    增加数据叫做**进栈**，移出数据则叫做**出栈**。

    因为上述的实现方式，栈中的所有数据都必须占用已知且固定大小的内存空间，假设数据大小是未知的，那么在取出数据时，你将无法取到你想要的数据。

*   堆

    与栈不同，对于大小未知或者可能变化的数据，我们需要将它存储在堆上。

    当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的**指针**, 该过程被称为\*\*==在堆上分配内存==\*\*，有时简称为 “分配”(allocating)。

    接着，该指针会被推入**栈**中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的**指针**，来获取数据在堆上的实际内存位置，进而访问该数据。

    由上可知，堆是一种缺乏组织的数据结构。*想象一下去餐馆就座吃饭: 进入餐馆，告知服务员有几个人，然后服务员找到一个够大的空桌子（堆上分配的内存空间）并领你们过去。如果有人来迟了，他们也可以通过桌号（栈上的指针）来找到你们坐在哪。*

*   性能区别

    在栈上分配内存比在堆上分配内存要快，因为入栈时操作系统无需进行函数调用（或更慢的系统调用）来分配新的空间，只需要将新数据放入栈顶即可。

*   **所有权原则**

    所有权的规则

    1.  Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
    2.  一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
    3.  当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)

*   变量作用域

    ```rust
    {                      // s 在这里无效，它尚未声明
        let s = "hello";   // 从此处起，s 是有效的

        // 使用 s
    }                      // 此作用域已结束，s不再有效

    ```

    简而言之，`s` 从创建开始就有效，然后有效期持续到它离开作用域为止。

*   简单介绍String类型

