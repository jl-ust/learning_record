## **2.4 复合类型**

*   **字符串**
*   **切片(slice)**

    对于字符串而言，切片就是对 `String` 类型中某一部分的引用：

```rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
```

*   这就是创建切片的语法，使用方括号包括的一个序列：**==\[开始索引..终止索引]==**，其中开始索引是切片中第一个元素的索引位置，而终止索引是最后一个元素后面的索引位置，也就是这是一个 `右半开区间`。在切片数据结构内部会保存开始的位置和切片的长度，其中长度是通过 ==`终止索引`==== - ====`开始索引`== 的方式计算得来的。
*   也可以截取完整的 `String` 切片：

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
```

> 在对字符串使用切片语法时需要格外小心，切片的索引必须落在字符之间的边界位置，也就是 UTF-8 字符的边界，例如中文在 UTF-8 中占用三个字节，下面的代码就会崩溃：

```rust
 let s = "中国人";
 let a = &s[0..2];
 println!("{}",a);

```

*   **其它切片**

    因为切片是对集合的部分引用，因此不仅仅字符串有切片，其它集合类型也有，例如数组：

```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];

assert_eq!(slice, &[2, 3]);

```

*   **字符串字面量是切片**

    `let s = "Hello, world!";`

    `s` 的类型是 `&str`

*   该切片指向了程序可执行文件中的某个点，这也是为什么字符串字面量是不可变的，因为 ==`&str`==== 是一个不可变引用==。

*   **什么是字符串?**

    > **Rust 中的字符是 ==Unicode 类型==，因此每个字符占据 4 个字节内存空间，但是在字符串中不一样，字符串是 ==UTF-8 编码==，也就是==字符串中的字符所占的字节数是变化的(1 - 4)==**，这样有助于大幅降低字符串所占用的内存空间。

    > `str` 类型是==硬编码进可执行文件==，也无法被修改，但是 `String` 则是一个==可增长、可改变且具有所有权的 UTF-8 编码字符串==，**当 Rust 用户提到字符串时，往往指的就是 `String` 类型和 `&str` 字符串切片类型，这两个类型都是 UTF-8 编码**。

*   **String 与 \&str 的转换**

    ```rust
    fn main() {
    let s = String::from("hello,world!");
    say_hello(&s);
    say_hello(&s[..]);
    say_hello(s.as_str());
    }
    fn say_hello(s: &str) {
    println!("{}",s);
    }
    ```

*   **字符串索引**

    使用索引的方式访问字符串的某个字符或者子串在 Rust 中会报错

*   深入字符串内部
    ```rust
       let s1 = String::from("hello");
       let h = s1[0];
    ```

*   字符串的底层的数据存储格式实际上是\[ `u8` ]，一个字节数组。对于 `let hello = String::from("Hola");` 这行代码来说，`Hola` 的长度是 `4` 个字节，因为 `"Hola"` 中的每个字母在 UTF-8 编码中仅占用 1 个字节

*   字符串的不同表现形式

    >  Rust 提供了不同的字符串展现方式，这样程序可以挑选自己想要的方式去使用，而无需去管字符串从人类语言角度看长什么样

*   **字符串切片**

    ==在通过索引区间来访问字符串时，==**==需要格外的小心==**，一不注意，就会导致程序崩溃！

*   **操作字符串**

    1.  追加 (Push)

        ```rust
        fn main() {
            let mut s = String::from("Hello ");

            s.push_str("rust");
            println!("追加字符串 push_str() -> {}", s);

            s.push('!');
            println!("追加字符 push() -> {}", s);
        }
        ```

        这两个方法都是**在原有的字符串上追加，并不会返回新的字符串**。由于字符串追加操作要修改原来的字符串，则该字符串必须是可变的，即\*\*==字符串变量必须由 ====`mut`==== 关键字修饰==\*\*==。==
    2.  插入 (Insert)

        ```rust
        fn main() {
            let mut s = String::from("Hello rust!");
            s.insert(5, ',');
            println!("插入字符 insert() -> {}", s);
            s.insert_str(6, " I like");
            println!("插入字符串 insert_str() -> {}", s);
        }
        ```

        这俩方法需要传入两个参数，第一个参数是==字符（串）插入位置的索引==，第二个参数是==要插入的字符（串）==，索引从 0 开始计数，如果越界则会发生错误。

        由于字符串插入操作要**修改原来的字符串**，则该字符串必须是可变的，即\*\*==字符串变量必须由 ====`mut`==== 关键字修饰==\*\*==。==
    3.  替换 (Replace)
    4.  删除 (Delete)
    5.  连接 (Concatenate)

*

