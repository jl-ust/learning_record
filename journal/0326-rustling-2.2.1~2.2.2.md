## 2.2 Rust基本类型

*   Rust 每个值都有其确切的数据类型，总的来说可以分为两类：==基本类型==和==复合类型==。 基本类型意味着它们往往是一个最小化原子类型，无法解构为其它类型(一般意义上来说)，由以下组成：

    ==数值类型==: 有符号整数 (`i8`, `i16`, `i32`, `i64`, `isize`)、 无符号整数 (`u8`, `u16`, `u32`, `u64`, `usize`) 、浮点数 (`f32`, `f64`)、以及有理数、复数

    ==字符串==：字符串字面量和字符串切片 `&str`

    ==布尔类型==： `true`和`false`  *++//也是c++学到了的++*

    ==字符类型==: 表示单个 Unicode 字符，存储为 4 个字节

    ==单元类型==: 即 `()` ，其唯一的值也是 `()`

&#x9;	`let guess: i32 = ...`

### 2.2.1 数值类型

*   **整数类型**

    **无符号数**表示数字只能取正数和0，而**有符号**则表示数字可以取正数、负数还有0

| 长度    | 有符号类型   | 无符号类型   |
| :---- | :------ | :------ |
| 8 位   | `i8`    | `u8`    |
| 16 位  | `i16`   | `u16`   |
| 32 位  | `i32`   | `u32`   |
| 64 位  | `i64`   | `u64`   |
| 128 位 | `i128`  | `u128`  |
| 视架构而定 | `isize` | `usize` |

> 这么多类型，有没有一个简单的使用准则？答案是肯定的， Rust 整型默认使用 `i32`，例如 `let i = 1`，那 `i` 就是 `i32` 类型，因此你可以首选它，同时该类型也往往是性能最好的。`isize` 和 `usize` 的主要应用场景是用作集合的索引。

*   **浮点类型**

    **浮点类型数字** 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： `f32` 和 `f64`，分别为 32 位和 64 位大小。默认浮点类型是 `f64`，在现代的 CPU 中它的速度与 `f32` 几乎相同，但精度更高。

*   浮点数陷阱

```rust
fn main() {
  // 断言0.1 + 0.2与0.3相等
  assert!(0.1 + 0.2 == 0.3);
}
```

这段代码没啥问题吧，实际上它会 *panic*(程序崩溃，抛出异常)，因为二进制精度问题，导致了 0.1 + 0.2 并不严格等于 0.3，它们可能在小数点 N 位后存在误差。

*   **NaN**

    对于数学上未定义的结果，例如对负数取平方根 `-42.1.sqrt()` ，会产生一个特殊的结果：Rust 的浮点数类型使用 `NaN` (not a number)来处理这些情况。

    **所有跟 `NaN` 交互的操作，都会返回一个 `NaN`**，而且 `NaN` 不能用来比较，

    出于防御性编程的考虑，可以使用 `is_nan()` 等方法，可以用来判断一个数值是否是 `NaN` ：

```rust
fn main() {
    let x = (-42.0_f32).sqrt();
    if x.is_nan() {
        println!("未定义的数学行为")
    }
}
```

*   **数字运算**

```rust
fn main() {
    // 加法
    let sum = 5 + 10;

    // 减法
    let difference = 95.5 - 4.3;

    // 乘法
    let product = 4 * 30;

    // 除法
    let quotient = 56.7 / 32.2;

    // 求余
    let remainder = 43 % 5;
}
```

```rust
fn main() {
  // 编译器会进行自动推导，给予twenty i32的类型
  let twenty = 20;
  // 类型标注
  let twenty_one: i32 = 21;
  // 通过类型后缀的方式进行类型标注：22是i32类型
  let twenty_two = 22i32;

  // 只有同样类型，才能运算
  let addition = twenty + twenty_one + twenty_two;
  println!("{} + {} + {} = {}", twenty, twenty_one, twenty_two, addition);

  // 对于较长的数字，可以用_进行分割，提升可读性
  let one_million: i64 = 1_000_000;
  println!("{}", one_million.pow(2));

  // 定义一个f32数组，其中42.0会自动被推导为f32类型
  let forty_twos = [
    42.0,
    42f32,
    42.0_f32,
  ];

  // 打印数组中第一个值，并控制小数位为2位
  println!("{:.2}", forty_twos[0]);
}
```

*   **位运算**

    没什么特别的

    | 运算符   | 说明                           |
    | :---- | :--------------------------- |
    | & 位与  | 相同位置均为1时则为1，否则为0             |
    | \| 位或 | 相同位置只要有1时则为1，否则为0            |
    | ^ 异或  | 相同位置不相同则为1，相同则为0             |
    | ! 位非  | 把位中的0和1相互取反，即0置为1，1置为0       |
    | << 左移 | 所有位向左移动指定位数，右位补0             |
    | >> 右移 | 所有位向右移动指定位数，带符号移动（正数补0，负数补1） |
*   **序列（Range）**

    超简洁

    Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 `1..5`，生成从 1 到 4 的连续数字，不包含 5 ；`1..=5`，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中：

```rust
for i in 1..=5 {
    println!("{}",i);
}
```

*   **有理数和复数**

&#x9;Rust 的标准库相比其它语言，准入门槛较高，因此有理数和复数并未包含在标准库中：

*   有理数和复数
*   任意大小的整数和任意精度的浮点数
*   固定精度的十进制小数，常用于货币相关的场景
    ### 2.2.2 字符、布尔、单元类型
    *   **字符类型(char)**

        所有的 `Unicode` 值都可以作为 Rust 字符，包括单个的中文、日文、韩文、emoji 表情符号等等，都是合法的字符类型。
    *   **布尔(bool)**++//也是c++接触到的++

        Rust 中的布尔类型有两个可能的值：`true` 和 `false`，布尔值占用内存的大小为 `1` 个字节：
    *   **单元类型**

        `fn main()`返回的就是`()`

&#x20;
